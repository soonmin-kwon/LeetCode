/**********************
 * Wiggle Subsequence *
 **********************/

class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        //dp[i][0]에는 현재 값이 +차례일 때 최대 길이를
        //dp[i][1]에는 현재 값이 -차례일 때 최대 길이를 저장
        vector<vector<int>> dp(nums.size(), vector<int>(2));
        //시작에는 1의 길이를 가짐
        dp[0][0] = 1;
        dp[0][1] = 1;
        
        //dp[i][0] 값은 현재 값이 +차례일 때이므로 바로 직전 -차례일 때 최대 길이에 따라 바뀐다.
        //dp[i][1] 값도 마찬가지로 바로 직전 +차례일 때 최대 길이에 따라 바뀐다.
        //dp[i][0]이 +차례이므로 이전 값보다 크면 정상적으로 길이가 늘어나고, 작으면 길이를 그대로 유지한다
        //dp[i][1]도 위와 마찬가지로 길이를 늘리거나 유지한다
        for(int i=1; i<nums.size(); i++){
            //현재 값이 이전 값보다 큰 경우
            if(nums[i] > nums[i-1]){
                //+차례일 때 길이는 +1이 되지만, -차례일 때 길이는 유지된다
                dp[i][0] = dp[i-1][1] + 1;
                dp[i][1] = dp[i-1][1];
            }
            //현재 값이 이전 값보다 작은 경우
            else if(nums[i] < nums[i-1]){
                //-차례일 때 길이는 +1이 되지만, +차례일 때 길이는 유지된다
                dp[i][0] = dp[i-1][0];
                dp[i][1] = dp[i-1][0] + 1;
            }
            //값이 같으면 모든 값이 그대로 유지된다
            else{
                dp[i][0] = dp[i-1][0];
                dp[i][1] = dp[i-1][1];
            }
        }
        
        return max(dp.back()[0], dp.back()[1]);
    }
};